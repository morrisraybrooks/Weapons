#!/usr/bin/env python3
"""
Malware Research Tool
Comprehensive obfuscation and analysis toolkit for authorized security research
"""

import argparse
import base64
import random
import os
import sys
import hashlib
import zlib
import struct
import re
from datetime import datetime

class ObfuscationEngine:
    """Multiple obfuscation techniques for security research"""
    
    def __init__(self):
        self.random = random.SystemRandom()
    
    # ==================== ENCODING TECHNIQUES ====================
    
    def base64_encode(self, data):
        """Standard Base64 encoding"""
        if isinstance(data, str):
            data = data.encode()
        return base64.b64encode(data).decode()
    
    def base64_decode(self, data):
        """Standard Base64 decoding"""
        return base64.b64decode(data).decode()
    
    def base32_encode(self, data):
        """Base32 encoding"""
        if isinstance(data, str):
            data = data.encode()
        return base64.b32encode(data).decode()
    
    def base16_encode(self, data):
        """Base16 (hex) encoding"""
        if isinstance(data, str):
            data = data.encode()
        return base64.b16encode(data).decode()
    
    def url_encode(self, data):
        """URL encoding"""
        from urllib.parse import quote
        return quote(data, safe='')
    
    # ==================== XOR TECHNIQUES ====================
    
    def xor_single_byte(self, data, key):
        """XOR with single byte key"""
        if isinstance(data, str):
            data = data.encode()
        return bytes([b ^ key for b in data])
    
    def xor_multi_byte(self, data, key):
        """XOR with multi-byte key"""
        if isinstance(data, str):
            data = data.encode()
        if isinstance(key, str):
            key = key.encode()
        return bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])
    
    def xor_rolling(self, data, initial_key=0x55):
        """XOR with rolling key (each byte affects next key)"""
        if isinstance(data, str):
            data = data.encode()
        result = []
        key = initial_key
        for b in data:
            encrypted = b ^ key
            result.append(encrypted)
            key = (key + b) & 0xFF
        return bytes(result)
    
    def find_xor_key(self, encrypted, known_plaintext):
        """Attempt to find XOR key given known plaintext"""
        if isinstance(encrypted, str):
            encrypted = encrypted.encode()
        if isinstance(known_plaintext, str):
            known_plaintext = known_plaintext.encode()
        
        keys = []
        for i in range(min(len(encrypted), len(known_plaintext))):
            keys.append(encrypted[i] ^ known_plaintext[i])
        return bytes(keys)
    
    # ==================== CIPHER TECHNIQUES ====================
    
    def rot13(self, data):
        """ROT13 encoding (Caesar cipher with shift 13)"""
        result = []
        for c in data:
            if 'a' <= c <= 'z':
                result.append(chr((ord(c) - ord('a') + 13) % 26 + ord('a')))
            elif 'A' <= c <= 'Z':
                result.append(chr((ord(c) - ord('A') + 13) % 26 + ord('A')))
            else:
                result.append(c)
        return ''.join(result)
    
    def caesar_cipher(self, data, shift):
        """Caesar cipher with custom shift"""
        result = []
        for c in data:
            if 'a' <= c <= 'z':
                result.append(chr((ord(c) - ord('a') + shift) % 26 + ord('a')))
            elif 'A' <= c <= 'Z':
                result.append(chr((ord(c) - ord('A') + shift) % 26 + ord('A')))
            else:
                result.append(c)
        return ''.join(result)
    
    def substitution_cipher(self, data, key_map=None):
        """Substitution cipher with custom alphabet mapping"""
        if key_map is None:
            # Generate random substitution alphabet
            alphabet = list('abcdefghijklmnopqrstuvwxyz')
            shuffled = alphabet.copy()
            self.random.shuffle(shuffled)
            key_map = dict(zip(alphabet, shuffled))
            # Add uppercase
            key_map.update({c.upper(): v.upper() for c, v in key_map.items()})
        
        result = ''.join(key_map.get(c, c) for c in data)
        return result, key_map
    
    def vigenere_cipher(self, data, key):
        """Vigenere cipher"""
        result = []
        key = key.upper()
        key_index = 0
        
        for c in data:
            if c.isalpha():
                shift = ord(key[key_index % len(key)]) - ord('A')
                if c.isupper():
                    result.append(chr((ord(c) - ord('A') + shift) % 26 + ord('A')))
                else:
                    result.append(chr((ord(c) - ord('a') + shift) % 26 + ord('a')))
                key_index += 1
            else:
                result.append(c)
        
        return ''.join(result)
    
    # ==================== STRING OBFUSCATION ====================
    
    def unicode_escape(self, data):
        """Convert to Unicode escape sequences"""
        return ''.join(f'\\u{ord(c):04x}' for c in data)
    
    def hex_escape(self, data):
        """Convert to hex escape sequences"""
        return ''.join(f'\\x{ord(c):02x}' for c in data)
    
    def octal_escape(self, data):
        """Convert to octal escape sequences"""
        return ''.join(f'\\{ord(c):03o}' for c in data)
    
    def char_code_array(self, data, language='python'):
        """Convert to character code array"""
        codes = [ord(c) for c in data]
        
        if language == 'python':
            return f"''.join(chr(c) for c in {codes})"
        elif language == 'javascript':
            return f"String.fromCharCode({','.join(map(str, codes))})"
        elif language == 'java':
            chars = ', '.join(f"(char){c}" for c in codes)
            return f"new String(new char[]{{{chars}}})"
        elif language == 'c':
            chars = ', '.join(str(c) for c in codes) + ', 0'
            return f"char s[] = {{{chars}}};"
        else:
            return str(codes)
    
    def string_concat(self, data, chunk_size=2):
        """Split string into concatenated chunks"""
        chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
        return ' + '.join(f'"{chunk}"' for chunk in chunks)
    
    def reverse_string(self, data):
        """Reverse the string"""
        return data[::-1]
    
    # ==================== COMPRESSION ====================
    
    def zlib_compress(self, data):
        """Zlib compression"""
        if isinstance(data, str):
            data = data.encode()
        compressed = zlib.compress(data, 9)
        return base64.b64encode(compressed).decode()
    
    def zlib_decompress(self, data):
        """Zlib decompression"""
        compressed = base64.b64decode(data)
        return zlib.decompress(compressed).decode()
    
    # ==================== MULTI-LAYER OBFUSCATION ====================
    
    def multi_layer_obfuscate(self, data, layers=['base64', 'xor', 'base64']):
        """Apply multiple obfuscation layers"""
        result = data
        key = self.random.randint(1, 255)
        
        for layer in layers:
            if layer == 'base64':
                result = self.base64_encode(result)
            elif layer == 'xor':
                result = self.xor_single_byte(result, key)
                if isinstance(result, bytes):
                    result = result.hex()
            elif layer == 'rot13':
                result = self.rot13(result)
            elif layer == 'reverse':
                result = self.reverse_string(result)
            elif layer == 'zlib':
                result = self.zlib_compress(result)
        
        return result, {'xor_key': key, 'layers': layers}


class PayloadGenerator:
    """Generate obfuscated payloads for various languages"""
    
    def __init__(self):
        self.engine = ObfuscationEngine()
    
    def python_payload(self, command, obfuscation='base64'):
        """Generate obfuscated Python payload"""
        if obfuscation == 'base64':
            encoded = self.engine.base64_encode(command)
            return f'''import base64
exec(base64.b64decode("{encoded}").decode())'''
        
        elif obfuscation == 'xor':
            key = random.randint(1, 255)
            encrypted = self.engine.xor_single_byte(command, key)
            hex_data = encrypted.hex()
            return f'''key = {key}
data = bytes.fromhex("{hex_data}")
exec(bytes([b ^ key for b in data]).decode())'''
        
        elif obfuscation == 'zlib':
            compressed = self.engine.zlib_compress(command)
            return f'''import base64, zlib
exec(zlib.decompress(base64.b64decode("{compressed}")).decode())'''
        
        elif obfuscation == 'charcode':
            codes = [ord(c) for c in command]
            return f'''exec(''.join(chr(c) for c in {codes}))'''
        
        elif obfuscation == 'multi':
            result, meta = self.engine.multi_layer_obfuscate(
                command, 
                layers=['base64', 'xor', 'base64', 'reverse']
            )
            return f'''import base64
def d(s, k):
    b = bytes.fromhex(s)
    return bytes([x ^ k for x in b])
data = "{result}"[::-1]
step1 = base64.b64decode(data)
step2 = d(step1.decode(), {meta['xor_key']})
exec(base64.b64decode(step2).decode())'''
    
    def powershell_payload(self, command, obfuscation='base64'):
        """Generate obfuscated PowerShell payload"""
        if obfuscation == 'base64':
            # PowerShell uses UTF-16LE for encoded commands
            encoded = base64.b64encode(command.encode('utf-16le')).decode()
            return f'powershell -EncodedCommand {encoded}'
        
        elif obfuscation == 'charcode':
            codes = ','.join(str(ord(c)) for c in command)
            return f'powershell -c "[char[]]@({codes})-join\'\' | iex"'
        
        elif obfuscation == 'concat':
            chunks = [command[i:i+3] for i in range(0, len(command), 3)]
            concat = '+'.join(f"'{c}'" for c in chunks)
            return f'powershell -c "iex({concat})"'
    
    def bash_payload(self, command, obfuscation='base64'):
        """Generate obfuscated Bash payload"""
        if obfuscation == 'base64':
            encoded = self.engine.base64_encode(command)
            return f'echo "{encoded}" | base64 -d | bash'
        
        elif obfuscation == 'hex':
            hex_cmd = command.encode().hex()
            return f'echo "{hex_cmd}" | xxd -r -p | bash'
        
        elif obfuscation == 'rev':
            reversed_cmd = command[::-1]
            return f'echo "{reversed_cmd}" | rev | bash'
        
        elif obfuscation == 'printf':
            octal = ''.join(f'\\{ord(c):03o}' for c in command)
            return f'$(printf "{octal}")'


class FileAnalyzer:
    """Analyze files for malware research"""
    
    def __init__(self):
        pass
    
    def calculate_hashes(self, file_path):
        """Calculate multiple hashes of a file"""
        hashes = {}
        algorithms = ['md5', 'sha1', 'sha256', 'sha512']
        
        try:
            with open(file_path, 'rb') as f:
                data = f.read()
                for algo in algorithms:
                    h = hashlib.new(algo)
                    h.update(data)
                    hashes[algo] = h.hexdigest()
        except Exception as e:
            hashes['error'] = str(e)
        
        return hashes
    
    def calculate_entropy(self, data):
        """Calculate Shannon entropy of data"""
        import math
        
        if isinstance(data, str):
            data = data.encode()
        
        if len(data) == 0:
            return 0.0
        
        frequency = {}
        for byte in data:
            frequency[byte] = frequency.get(byte, 0) + 1
        
        entropy = 0.0
        for count in frequency.values():
            probability = count / len(data)
            entropy -= probability * math.log2(probability)
        
        return entropy
    
    def analyze_file(self, file_path):
        """Comprehensive file analysis"""
        results = {
            'file_path': file_path,
            'analysis_time': datetime.now().isoformat()
        }
        
        try:
            # Basic file info
            stat = os.stat(file_path)
            results['size'] = stat.st_size
            results['modified'] = datetime.fromtimestamp(stat.st_mtime).isoformat()
            
            # Hashes
            results['hashes'] = self.calculate_hashes(file_path)
            
            # Read file
            with open(file_path, 'rb') as f:
                data = f.read()
            
            # Entropy
            results['entropy'] = self.calculate_entropy(data)
            results['high_entropy'] = results['entropy'] > 7.0
            
            # Magic bytes
            results['magic_bytes'] = data[:16].hex()
            
            # String extraction
            strings = self.extract_strings(data)
            results['string_count'] = len(strings)
            results['interesting_strings'] = self.find_interesting_strings(strings)
            
            # Detect encoding/packing
            results['likely_packed'] = results['entropy'] > 7.5
            results['likely_encoded'] = self.detect_encoding(data)
            
        except Exception as e:
            results['error'] = str(e)
        
        return results
    
    def extract_strings(self, data, min_length=4):
        """Extract printable strings from binary data"""
        pattern = rb'[\x20-\x7e]{' + str(min_length).encode() + rb',}'
        return [s.decode('ascii') for s in re.findall(pattern, data)]
    
    def find_interesting_strings(self, strings):
        """Find potentially interesting strings"""
        patterns = {
            'urls': r'https?://[^\s<>"{}|\\^`\[\]]+',
            'ips': r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b',
            'emails': r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}',
            'registry': r'HKEY_[A-Z_]+\\[^\s]+',
            'paths': r'[A-Za-z]:\\[^\s<>"{}|\\^`\[\]]+',
            'commands': r'(cmd|powershell|bash|sh|python|wget|curl|nc)\b'
        }
        
        interesting = {}
        full_text = '\n'.join(strings)
        
        for name, pattern in patterns.items():
            matches = re.findall(pattern, full_text, re.IGNORECASE)
            if matches:
                interesting[name] = list(set(matches))[:20]
        
        return interesting
    
    def detect_encoding(self, data):
        """Detect common encoding methods"""
        detections = []
        
        # Check for Base64
        try:
            decoded = base64.b64decode(data[:1000])
            if len(decoded) > 10:
                detections.append('possible_base64')
        except:
            pass
        
        # Check for high ratio of specific byte ranges
        printable = sum(1 for b in data if 32 <= b <= 126)
        ratio = printable / len(data) if data else 0
        
        if ratio > 0.9:
            detections.append('mostly_printable')
        elif ratio < 0.3:
            detections.append('mostly_binary')
        
        return detections


def show_warning():
    print("\n" + "="*60)
    print("  MALWARE RESEARCH TOOL - FOR AUTHORIZED RESEARCH ONLY")
    print("="*60)
    print("  This tool is intended for security research purposes.")
    print("  Unauthorized malicious use is strictly prohibited.")
    print("="*60 + "\n")


def main():
    parser = argparse.ArgumentParser(
        description="Malware Research Tool - Obfuscation and Analysis"
    )
    subparsers = parser.add_subparsers(dest='command', required=True)
    
    # List techniques
    subparsers.add_parser('list', help='List available techniques')
    
    # Obfuscate
    obf_parser = subparsers.add_parser('obfuscate', help='Obfuscate data')
    obf_parser.add_argument('technique', choices=[
        'base64', 'base32', 'hex', 'xor', 'rot13', 'caesar',
        'unicode', 'hexescape', 'charcode', 'reverse', 'zlib', 'multi'
    ])
    obf_parser.add_argument('data', help='Data to obfuscate')
    obf_parser.add_argument('--key', help='Key for XOR/Caesar (int)', type=int, default=13)
    obf_parser.add_argument('--language', choices=['python', 'javascript', 'java', 'c'], default='python')
    
    # Deobfuscate
    deobf_parser = subparsers.add_parser('deobfuscate', help='Deobfuscate data')
    deobf_parser.add_argument('technique', choices=['base64', 'xor', 'rot13', 'zlib', 'reverse'])
    deobf_parser.add_argument('data', help='Data to deobfuscate')
    deobf_parser.add_argument('--key', help='Key for XOR', type=int, default=0)
    
    # Generate payload
    gen_parser = subparsers.add_parser('generate', help='Generate obfuscated payload')
    gen_parser.add_argument('language', choices=['python', 'powershell', 'bash'])
    gen_parser.add_argument('command', help='Command to obfuscate')
    gen_parser.add_argument('--obfuscation', choices=['base64', 'xor', 'charcode', 'zlib', 'multi', 'hex', 'rev', 'concat'], default='base64')
    
    # Analyze file
    analyze_parser = subparsers.add_parser('analyze', help='Analyze a file')
    analyze_parser.add_argument('file', help='File to analyze')
    
    # XOR key finder
    xor_parser = subparsers.add_parser('findkey', help='Find XOR key')
    xor_parser.add_argument('encrypted', help='Encrypted data (hex)')
    xor_parser.add_argument('plaintext', help='Known plaintext')
    
    args = parser.parse_args()
    
    show_warning()
    
    engine = ObfuscationEngine()
    generator = PayloadGenerator()
    analyzer = FileAnalyzer()
    
    if args.command == 'list':
        print("=== Available Obfuscation Techniques ===\n")
        print("Encoding:")
        print("  - base64    : Base64 encoding")
        print("  - base32    : Base32 encoding")
        print("  - hex       : Hexadecimal encoding")
        print("\nCiphers:")
        print("  - xor       : XOR with key")
        print("  - rot13     : ROT13 cipher")
        print("  - caesar    : Caesar cipher with custom shift")
        print("\nString Obfuscation:")
        print("  - unicode   : Unicode escape sequences")
        print("  - hexescape : Hex escape sequences")
        print("  - charcode  : Character code array")
        print("  - reverse   : Reverse string")
        print("\nCompression:")
        print("  - zlib      : Zlib compression + Base64")
        print("\nAdvanced:")
        print("  - multi     : Multi-layer obfuscation")
    
    elif args.command == 'obfuscate':
        print(f"Obfuscating with {args.technique}...\n")
        
        if args.technique == 'base64':
            result = engine.base64_encode(args.data)
        elif args.technique == 'base32':
            result = engine.base32_encode(args.data)
        elif args.technique == 'hex':
            result = engine.base16_encode(args.data)
        elif args.technique == 'xor':
            result = engine.xor_single_byte(args.data, args.key).hex()
            print(f"XOR Key: {args.key}")
        elif args.technique == 'rot13':
            result = engine.rot13(args.data)
        elif args.technique == 'caesar':
            result = engine.caesar_cipher(args.data, args.key)
            print(f"Shift: {args.key}")
        elif args.technique == 'unicode':
            result = engine.unicode_escape(args.data)
        elif args.technique == 'hexescape':
            result = engine.hex_escape(args.data)
        elif args.technique == 'charcode':
            result = engine.char_code_array(args.data, args.language)
        elif args.technique == 'reverse':
            result = engine.reverse_string(args.data)
        elif args.technique == 'zlib':
            result = engine.zlib_compress(args.data)
        elif args.technique == 'multi':
            result, meta = engine.multi_layer_obfuscate(args.data)
            print(f"Layers: {meta['layers']}")
            print(f"XOR Key: {meta['xor_key']}")
        
        print(f"\nResult:\n{result}")
    
    elif args.command == 'deobfuscate':
        print(f"Deobfuscating with {args.technique}...\n")
        
        if args.technique == 'base64':
            result = engine.base64_decode(args.data)
        elif args.technique == 'xor':
            data = bytes.fromhex(args.data)
            result = engine.xor_single_byte(data, args.key).decode()
        elif args.technique == 'rot13':
            result = engine.rot13(args.data)
        elif args.technique == 'zlib':
            result = engine.zlib_decompress(args.data)
        elif args.technique == 'reverse':
            result = engine.reverse_string(args.data)
        
        print(f"Result:\n{result}")
    
    elif args.command == 'generate':
        print(f"Generating {args.language} payload with {args.obfuscation} obfuscation...\n")
        
        if args.language == 'python':
            result = generator.python_payload(args.command, args.obfuscation)
        elif args.language == 'powershell':
            result = generator.powershell_payload(args.command, args.obfuscation)
        elif args.language == 'bash':
            result = generator.bash_payload(args.command, args.obfuscation)
        
        print(f"Payload:\n{result}")
    
    elif args.command == 'analyze':
        print(f"Analyzing {args.file}...\n")
        results = analyzer.analyze_file(args.file)
        
        for key, value in results.items():
            if isinstance(value, dict):
                print(f"\n{key.upper()}:")
                for k, v in value.items():
                    print(f"  {k}: {v}")
            else:
                print(f"{key}: {value}")
    
    elif args.command == 'findkey':
        encrypted = bytes.fromhex(args.encrypted)
        key = engine.find_xor_key(encrypted, args.plaintext)
        print(f"Possible XOR key: {key.hex()}")
        print(f"Key bytes: {list(key)}")


if __name__ == "__main__":
    main()
