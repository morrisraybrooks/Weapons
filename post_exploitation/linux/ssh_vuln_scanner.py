#!/usr/bin/env python3
"""
Enhanced SSH Vulnerability Scanner
Author: Agent Zero
Date: 2026-01-20
Description: Comprehensive SSH vulnerability and misconfiguration detection
"""

import argparse
import socket
import paramiko
import sys
import re
from datetime import datetime

class SSHVulnScanner:
    def __init__(self, target, port=22, timeout=5):
        self.target = target
        self.port = port
        self.timeout = timeout
        self.vulnerabilities = []
        self.findings = []
        self.ssh = paramiko.SSHClient()
        self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
    def log(self, message):
        """Log messages with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] {message}")
        
    def check_ssh_accessible(self):
        """Check if SSH port is accessible"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            result = sock.connect_ex((self.target, self.port))
            sock.close()
            return result == 0
        except Exception as e:
            self.log(f"Error: {e}")
            return False
            
    def check_version_vulnerabilities(self, version):
        """Check for known vulnerable SSH versions"""
        vulnerable_versions = {
            'OpenSSH_7.2p2': 'CVE-2016-0777 (Information leak)',
            'OpenSSH_7.5': 'CVE-2017-15906 (Username enumeration)',
            'OpenSSH_7.7': 'CVE-2018-15473 (Username enumeration)',
            'OpenSSH_8.0': 'CVE-2019-6111 (File overwrite)',
            'OpenSSH_8.1': 'CVE-2020-14145 (Information leak)',
            'OpenSSH_8.2': 'CVE-2020-15778 (Command injection)',
            'OpenSSH_8.5': 'CVE-2021-28041 (Authentication bypass)'
        }
        
        for vuln_version, cve in vulnerable_versions.items():
            if vuln_version in version:
                self.vulnerabilities.append(f"VULNERABLE: {version} ({cve})")
                
    def check_auth_methods(self):
        """Check available authentication methods"""
        try:
            transport = paramiko.Transport((self.target, self.port))
            transport.connect()
            auth_methods = transport.auth_none('')
            transport.close()
            
            if 'password' in auth_methods:
                self.vulnerabilities.append("WEAK: Password authentication enabled")
                self.findings.append("Brute force vulnerability: Password authentication allows credential guessing")
            if 'publickey' not in auth_methods:
                self.vulnerabilities.append("MISSING: Public key authentication not available")
            if 'keyboard-interactive' in auth_methods:
                self.findings.append("Potential vulnerability: Keyboard-interactive auth may allow brute force")
                
        except Exception as e:
            self.log(f"Error: {e}")
            
    def check_weak_algorithms(self):
        """Check for weak encryption algorithms"""
        weak_algorithms = ['arcfour', 'blowfish-cbc', '3des-cbc', 'aes128-cbc', 'aes192-cbc', 'aes256-cbc']
        try:
            transport = paramiko.Transport((self.target, self.port))
            transport.connect()
            
            for alg_type in ['ciphers', 'macs', 'key_types']:
                algorithms = getattr(transport, f'get_{alg_type}')()
                for weak_alg in weak_algorithms:
                    if weak_alg in algorithms:
                        self.vulnerabilities.append(f"WEAK ALGORITHM: {weak_alg} in {alg_type}")
            transport.close()
                
        except Exception as e:
            self.log(f"Error: {e}")
            
    def check_user_enumeration(self):
        """Check for user enumeration vulnerability (CVE-2018-15473)"""
        try:
            # Test for timing differences in authentication
            transport = paramiko.Transport((self.target, self.port))
            transport.connect()
            
            # Test with invalid user
            start_time = datetime.now()
            try:
                transport.auth_password('invalid_user_12345', 'password')
            except:
                pass
            invalid_time = (datetime.now() - start_time).total_seconds()
            
            # Test with potentially valid user (root)
            start_time = datetime.now()
            try:
                transport.auth_password('root', 'password')
            except:
                pass
            root_time = (datetime.now() - start_time).total_seconds()
            
            transport.close()
            
            if root_time > invalid_time * 1.5:  # Significant timing difference
                self.vulnerabilities.append("VULNERABLE: User enumeration possible (CVE-2018-15473)")
                self.findings.append("User enumeration: Timing attack successful - valid users can be identified")
                
        except Exception as e:
            self.log(f"Error: {e}")
            
    def check_brute_force_vulnerability(self):
        """Check for brute force protection"""
        try:
            # Test multiple failed login attempts
            failed_attempts = 0
            for i in range(3):
                transport = paramiko.Transport((self.target, self.port))
                transport.connect()
                try:
                    transport.auth_password('root', f'invalid_password_{i}')
                except paramiko.AuthenticationException:
                    failed_attempts += 1
                except Exception as e:
                    self.log(f"Error during brute force test: {e}")
                    break
                transport.close()
            
            if failed_attempts == 3:
                self.findings.append("Brute force risk: No account lockout detected after 3 failed attempts")
                self.vulnerabilities.append("WEAK: No brute force protection detected")
                
        except Exception as e:
            self.log(f"Error: {e}")
            
    def check_ssh_banner(self):
        """Analyze SSH banner for information disclosure"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((self.target, self.port))
            banner = sock.recv(1024).decode('utf-8').strip()
            sock.close()
            
            self.log(f"SSH Banner: {banner}")
            
            # Check for excessive information
            if 'OpenSSH' in banner and len(banner.split()) > 2:
                self.findings.append(f"Information disclosure: Detailed SSH version in banner ({banner})")
            
            # Check for default banners
            default_banners = [
                'OpenSSH', 'SSH-2.0-OpenSSH', 'Debian', 'Ubuntu', 'CentOS'
            ]
            for default in default_banners:
                if default in banner:
                    self.findings.append(f"Default configuration: Banner contains '{default}'")
                    
        except Exception as e:
            self.log(f"Error: {e}")
            
    def check_configuration_files(self):
        """Check for common SSH configuration issues"""
        try:
            # This would require authenticated access in a real scenario
            # For demonstration, we'll simulate common misconfigurations
            common_issues = {
                'PermitRootLogin': ['yes', 'without-password'],
                'PasswordAuthentication': ['yes'],
                'PermitEmptyPasswords': ['yes'],
                'X11Forwarding': ['yes'],
                'AllowTcpForwarding': ['yes']
            }
            
            self.findings.append("Configuration check: Review /etc/ssh/sshd_config for:")
            for setting, risky_values in common_issues.items():
                self.findings.append(f"  - {setting}: Should not be {', '.join(risky_values)}")
                
        except Exception as e:
            self.log(f"Error: {e}")
            
    def scan(self):
        """Run complete SSH vulnerability scan"""
        self.log(f"Scanning {self.target}:{self.port}")
        
        if not self.check_ssh_accessible():
            self.log(f"SSH not accessible on {self.target}:{self.port}")
            return False
            
        try:
            # Get SSH version
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((self.target, self.port))
            version = sock.recv(255).decode('utf-8').strip()
            sock.close()
            
            self.log(f"SSH version: {version}")
            self.check_version_vulnerabilities(version)
            
            # Check authentication methods
            self.check_auth_methods()
            
            # Check for weak algorithms
            self.check_weak_algorithms()
            
            # Check for user enumeration
            self.check_user_enumeration()
            
            # Check brute force vulnerability
            self.check_brute_force_vulnerability()
            
            # Check SSH banner
            self.check_ssh_banner()
            
            # Check configuration files
            self.check_configuration_files()
            
            return True
            
        except Exception as e:
            self.log(f"Error: {e}")
            return False
            
    def report(self):
        """Generate comprehensive vulnerability report"""
        if not self.vulnerabilities and not self.findings:
            self.log("No vulnerabilities or findings detected")
            return
            
        self.log("\n=== VULNERABILITY REPORT ===")
        if self.vulnerabilities:
            for i, vuln in enumerate(self.vulnerabilities, 1):
                self.log(f"{i}. {vuln}")
        
        if self.findings:
            self.log("\n=== ADDITIONAL FINDINGS ===")
            for i, finding in enumerate(self.findings, 1):
                self.log(f"{i}. {finding}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Enhanced SSH Vulnerability Scanner")
    parser.add_argument("target", help="Target IP or hostname")
    parser.add_argument("-p", "--port", type=int, default=22, help="SSH port (default: 22)")
    parser.add_argument("-t", "--timeout", type=int, default=5, help="Connection timeout (default: 5)")
    parser.add_argument("--log-file", help="Log file path")
    
    args = parser.parse_args()
    
    scanner = SSHVulnScanner(args.target, args.port, args.timeout)
    
    if args.log_file:
        # Redirect stdout to log file
        original_stdout = sys.stdout
        with open(args.log_file, 'w') as f:
            sys.stdout = f
            success = scanner.scan()
            if success:
                scanner.report()
        sys.stdout = original_stdout
        print(f"Scan completed. Results saved to {args.log_file}")
    else:
        success = scanner.scan()
        if success:
            scanner.report()
